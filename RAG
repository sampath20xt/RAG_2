def run_query(mongo_query):
    try:
        # Parse the SQL-like query and decide which collections to query
        if "JOIN" in mongo_query:
            # Extract collection names and conditions for JOIN
            left_table = mongo_query.split("FROM")[1].split("AS")[0].strip()
            right_table = mongo_query.split("JOIN")[1].split("AS")[0].strip()
            on_condition = mongo_query.split("ON")[1].split("WHERE")[0].strip()
            where_condition = mongo_query.split("WHERE")[1].strip()
            
            # Parse ON condition (e.g., "t.firm = p.firm")
            left_field, right_field = [cond.strip() for cond in on_condition.split("=")]
            left_field = left_field.split(".")[1]  # Get field name after table alias
            right_field = right_field.split(".")[1]
            
            # Parse WHERE condition (e.g., "p.title = 'Administrative law'")
            filters = {}
            if "AND" in where_condition:
                conditions = where_condition.split("AND")
                for cond in conditions:
                    field, value = cond.split("=") if "=" in cond else cond.split("LIKE")
                    field = field.strip().split(".")[1]  # Get field name after table alias
                    value = value.strip().strip("'").replace("%", ".*")  # Convert SQL LIKE to regex
                    filters[field] = {"$regex": value, "$options": "i"}  # Case-insensitive match
            
            # MongoDB aggregation pipeline
            pipeline = [
                {"$lookup": {
                    "from": right_table,
                    "localField": left_field,
                    "foreignField": right_field,
                    "as": "joined_data"
                }},
                {"$unwind": "$joined_data"},
                {"$match": filters},
                {"$project": {"name": 1}}
            ]
            
            # Query the left collection with the pipeline
            collection = db[left_table]
            result = collection.aggregate(pipeline)
            
            # Convert results to a list of dictionaries
            result_list = [doc for doc in result]
            return result_list
        else:
            # Handle non-join queries
            raise ValueError("Only JOIN queries are supported in this implementation.")
    except Exception as e:
        return {"error": str(e)}
