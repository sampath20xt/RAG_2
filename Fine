import json
import os
from pymongo import MongoClient
from bson import json_util
from sentence_transformers import SentenceTransformer
import chromadb
import streamlit as st

# Original Code (Unchanged)
mongo_url = "mongodb+srv://admin:Sampath@cluster01.wcpmehz.mongodb.net/"
mongo_client = MongoClient(mongo_url)
database = mongo_client["RAG"]

# Collections
collections = ["articles", "careers", "practices", "teams"]
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "email-extraction-381718-3f73208ce3b71.json"

# Initialize ChromaDB client and collection
chroma_client = chromadb.Client()
chroma_collection = chroma_client.create_collection(name="RAG_collection")


# Function to retrieve MongoDB schema
def get_schema(db):
    schema_info = {}
    collections = db.list_collection_names()
    for collection_name in collections:
        collection = db[collection_name]
        sample_record = collection.find_one()
        if sample_record:
            schema_info[collection_name] = {key: type(value).__name__ for key, value in sample_record.items()}
        else:
            schema_info[collection_name] = "No records found"
    return schema_info


# Generate embeddings for ChromaDB
def generate_embedding(query):
    model = SentenceTransformer('multi-qa-distilbert-cos-v1')
    return model.encode(query)


def get_all_collection_schemas_and_store_prompts():
    schema = get_schema(database)  # Retrieve schema information from MongoDB
    print(schema)

    for collection_name, fields in schema.items():
        field_names = ' '.join(fields.keys())
        schema_info = f"{collection_name}:{field_names}"

        # Create a prompt for storing schema info in ChromaDB
        prompt = f"<SCHEMA>{schema_info}</SCHEMA>"
        chroma_collection.upsert(
            ids=[collection_name],
            metadatas=[{"collection_name": collection_name, "schema_info": schema_info, "prompt": prompt}],
            embeddings=generate_embedding(schema_info)
        )
    return schema


def similar_table(query, chroma_collection, model):
    query_embedding = model.encode(query)

    # Perform vector search
    results = chroma_collection.query(query_embeddings=[query_embedding], n_results=1)

    if results and results["metadatas"]:
        metadata = results["metadatas"][0]
        return metadata.get("collection_name"), metadata.get("schema_info")
    return None, None


def execute_generated_query(generated_query, db):
    try:
        print("Generated Query:", generated_query)  # Debugging

        # Parse collection name and query type
        collection_name = generated_query.split('["')[1].split('"]')[0]
        query_type = generated_query.split('.')[1].split('(')[0]
        query_params = generated_query.split('(', 1)[1].rsplit(')', 1)[0]
        collection = db[collection_name]

        # Handle query execution by type
        if query_type == "find":
            if ',' in query_params:  # Check for projection
                query, projection = query_params.split(",", 1)
                query = json.loads(query.strip())
                projection = json.loads(projection.strip())
                result = list(collection.find(query, projection))
            else:  # No projection
                query = json.loads(query_params.strip())
                result = list(collection.find(query))

        elif query_type == "count_documents":
            query = json.loads(query_params.strip().replace("'", '"'))
            result = collection.count_documents(query)

        elif query_type == "aggregate":
            pipeline = json_util.loads(query_params.strip().replace("'", '"'))
            result = list(collection.aggregate(pipeline))

        elif query_type == "distinct":
            query_field = query_params.strip().replace("'", '"')
            result = list(collection.distinct(query_field))

        else:
            raise ValueError(f"Unsupported query type: {query_type}")

        print("Query Result:", result)
        return result

    except json.JSONDecodeError as e:
        print(f"JSON Decode Error: {e}")
        return {"error": f"JSON Decode Error: {str(e)}"}
    except Exception as e:
        print(f"Error during query execution: {e}")
        return {"error": str(e)}


# Streamlit Application Code
# Initialize session state for chat history
if "chat_store" not in st.session_state:
    st.session_state["chat_store"] = {}

# Function to display chat history
def display_chat_history():
    session_id = "default_session"  # You can modify session handling if needed
    if session_id not in st.session_state["chat_store"]:
        st.session_state["chat_store"][session_id] = []
    for message in st.session_state["chat_store"][session_id]:
        message_type = "AI" if message.get("is_ai") else "Human"
        st.chat_message(message_type).write(message["content"])

# Function to add a message to chat history
def add_to_chat_history(content, is_ai=False):
    session_id = "default_session"  # You can extend this to support multiple sessions
    st.session_state["chat_store"][session_id].append({"content": content, "is_ai": is_ai})

# Function to handle user input
def handle_user_input():
    user_query = st.chat_input("Type your question ✍️")
    if user_query:
        # Add user message to chat history
        add_to_chat_history(user_query, is_ai=False)

        # Simulate query generation (replace with your AI-based query generation function)
        with st.spinner("Generating query..."):
            generated_query = f'db["articles"].find({{"title": "{user_query}"}})'  # Placeholder logic

        # Add generated query to chat history
        add_to_chat_history(f"Generated Query: {generated_query}", is_ai=True)

        # Simulate query execution (replace with actual MongoDB query execution)
        with st.spinner("Executing query..."):
            result = execute_generated_query(generated_query, database)

        # Add query result to chat history
        add_to_chat_history(f"Query Result: {result}", is_ai=True)

        st.experimental_rerun()

# Streamlit Layout
st.title("RAG Chat Interface")
st.write("Welcome to the RAG Chat Interface powered by MongoDB and ChromaDB.")

# Display chat history
display_chat_history()

# Handle user input
handle_user_input()
