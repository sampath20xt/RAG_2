import streamlit as st
from pymongo import MongoClient
from vertexai.generative_models import GenerativeModel
import json
from bson import json_util

# Streamlit page setup
st.set_page_config(page_title="RAG Chatbot", layout="centered")

# MongoDB connection setup
mongo_url = "mongodb+srv://admin:Sampath@cluster01.wcpmehz.mongodb.net/"
mongo_client = MongoClient(mongo_url)
database = mongo_client["RAG"]

# Vertex AI generative model setup
vertexai.init(project="email-extraction-381718", location="us-central1")
generative_multimodal_model = GenerativeModel("gemini-1.5-pro-001")

# Custom CSS for chatbot styling
st.markdown("""
    <style>
        .chat-container {
            max-width: 700px;
            margin: auto;
        }
        .chat-bubble-user {
            background-color: #DCF8C6;
            border-radius: 15px;
            padding: 10px;
            margin: 5px 0;
            width: fit-content;
            align-self: flex-end;
        }
        .chat-bubble-bot {
            background-color: #E8E8E8;
            border-radius: 15px;
            padding: 10px;
            margin: 5px 0;
            width: fit-content;
            align-self: flex-start;
        }
        .chat-history {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #CCC;
            border-radius: 10px;
            background-color: #F9F9F9;
        }
        .input-container {
            margin-top: 10px;
            display: flex;
        }
    </style>
""", unsafe_allow_html=True)

# Session state to store conversation history
if "conversation" not in st.session_state:
    st.session_state.conversation = []

# Function to generate MongoDB query from user question
def generate_query(question):
    prompt = f"""
        You are a MongoDB expert. Your task is to generate accurate MongoDB queries based on the schema provided below.
        Add double quotes to all the field names while generating the MongoDB query.
        Use the schema and sample questions provided to guide the generation.

        <SCHEMA>
        - Collection: articles
          Fields: ["_id", "title", "body", "area", "firm"]

        - Collection: careers
          Fields: ["_id", "position", "location", "experience", "employment type", "compensation", "pay type", "firm"]

        - Collection: practices
          Fields: ["_id", "title", "specializations", "leaders", "team members", "firm"]

        - Collection: teams
          Fields: ["_id", "name", "position", "phone", "email", "education", "achievements", "admissions", "affiliations", "firm"]

        Question: {question}
        MongoDB Query:
    """
    generation_config = {
        "max_output_tokens": 8192,
        "temperature": 0.3,
        "top_p": 0.5,
    }

    response = generative_multimodal_model.generate_content([prompt],
                                                            generation_config=generation_config)

    return response.text.strip()

# Function to execute the generated MongoDB query
def execute_generated_query(generated_query, db):
    try:
        collection_name = generated_query.split('["')[1].split('"]')[0]
        query_type = generated_query.split('.')[1].split('(')[0]
        query_params = generated_query.split('(', 1)[1].rsplit(')', 1)[0]
        collection = db[collection_name]

        if query_type == "find":
            if ',' in query_params:
                query, projection = query_params.split(",", 1)
                query = json.loads(query.strip())
                projection = json.loads(projection.strip())
                result = list(collection.find(query, projection))
            else:
                query = json.loads(query_params.strip())
                result = list(collection.find(query))
        elif query_type == "aggregate":
            pipeline = json_util.loads(query_params.strip())
            result = list(collection.aggregate(pipeline))
        else:
            raise ValueError(f"Unsupported query type: {query_type}")

        return result

    except Exception as e:
        return {"error": str(e)}

# Chatbot interface
st.title("RAG Chatbot")
st.markdown('<div class="chat-container">', unsafe_allow_html=True)

# Display chat history
st.markdown('<div class="chat-history">', unsafe_allow_html=True)
for message in st.session_state.conversation:
    if message["sender"] == "user":
        st.markdown(f'<div class="chat-bubble-user">{message["message"]}</div>', unsafe_allow_html=True)
    else:
        st.markdown(f'<div class="chat-bubble-bot">{message["message"]}</div>', unsafe_allow_html=True)
st.markdown('</div>', unsafe_allow_html=True)

# User input for the question
with st.form("chat_form", clear_on_submit=True):
    user_input = st.text_input("Type your question:", "")
    submitted = st.form_submit_button("Send")
    
    if submitted and user_input:
        # Append user message to chat history
        st.session_state.conversation.append({"sender": "user", "message": user_input})

        # Generate MongoDB query
        query = generate_query(user_input)
        st.session_state.conversation.append({"sender": "bot", "message": f"Generated Query:\n{query}"})

        # Execute query and get the result
        result = execute_generated_query(query, database)
        if "error" in result:
            bot_response = f"Error: {result['error']}"
        else:
            bot_response = f"Result:\n{result}"
        st.session_state.conversation.append({"sender": "bot", "message": bot_response})

st.markdown('</div>', unsafe_allow_html=True)
